## 简介
JMM是Java程序对线程如何交互的统一的约定协议.

Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。

本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

Java内存模型的抽象示意图如下：

![](../images/java-5-1.png)

## 线程通信与消息传递
从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

- 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
- 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。

![](../images/java-5-2.png)

如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。

从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。

## 堆内存共享范围
- 共享
    - 实例域
    - 静态域
    - 数组元素
- 不共享
    - 局部变量（Local variables）
    - 方法定义参数（java语言规范称之为formal method parameters）
    - 异常处理器参数（exception handler parameters）

## JMM特性
- 指令重排序
- 顺序一致性
- Happens-Before
- As-if-Serial

### 顺序一致性

### 指令重排序
　在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：

1. 编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：
![](https://images0.cnblogs.com/i/475287/201403/091511346284594.png)

为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种：

!][](https://images0.cnblogs.com/i/475287/201403/091516513623330.png)

## Happens-Before规则列表
HappendBefore规则包括

1. **程序顺序规则**: 如果程序中操作A在操作B之前，那么同一个线程中操作A将在操作B之前进行
2. **监视器锁规则**: 在监视器锁上的锁操作必须在同一个监视器锁上的加锁操作之前执行
3. **volatile变量规则**: volatile变量的写入操作必须在该变量的读操作之前执行
4. **线程启动规则**: 在线程上对Thread.start的调用必须在该线程中执行任何操作之前执行
5. **线程结束规则**: 线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行
6. **中断规则**: 当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt之前执行
7. **传递性**: 如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A在操作C之前执行。

其中显示锁与监视器锁有相同的内存语义，原子变量与volatile有相同的内存语义。锁的获取和释放、volatile变量的读取和写入操作满足全序关系，所以可以使用volatile的写入在后续的volatile的读取之前进行。
可以利用上述Happens-Before的多个规则进行组合。
例如线程A进入监视器锁后，在释放监视器锁之前的操作根据程序顺序规则Happens-Before于监视器释放操作，而监视器释放操作Happens-Before于后续的线程B的对相同监视器锁的获取操作，获取操作Happens-Before与线程B中的操作。

## as-if-serial语义
as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义