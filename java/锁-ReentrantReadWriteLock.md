ReentrantReadWriteLock

## 如何理解
ReentrantReadWriteLock按照字面意思是读写锁，如果你把它理解为对IO的控制，那就大错特错了（其实大多数人的直觉是这样）。其实你只要把它理解成一个数据库的事务锁就对了。众所周知数据库事务锁的特点就是，读写分离。而ReentrantReadWriteLock是类似最高级的事务级别Serializable可串行化（严格讲比这个还更严谨）。什么意思呢，意思就是，对一条数据的更新操作只影响其它对该条数据的更新操作，而读操作是不影响的。   而并发锁Lock也好，synchronizy也好，是直接把读写都锁住的。就是说，该代码块一但锁住之后，既不能读也不能写。 但这样是有问题的，有些线程只是想读取一下数据，我又不改数据，你锁它干嘛呢？（类似事物吧） 所以ReentrantReadWriteLock把锁拆分成了读锁和写锁。  写锁之间的互斥的，但读锁不互斥（大家一起读数据么，压根就没冲突）。 但是有一点要注意。就是你想获取写锁，是除当前线程外，不能存在其它的读锁的。  好比就是说，我要改里面的数据了，那些获取了读锁的线程，必须通通退出来，否则会出现读到老数据的问题（类似事物里面的脏读） ，获取到写锁之后，其它线程也不能再获取到读锁了。

参考资料
- https://www.cnblogs.com/xiaoxi/p/9140541.html